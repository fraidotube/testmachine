import subprocess
from fastapi import APIRouter, Request, Query
from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse, FileResponse
from util.shell import run
import os, re, tarfile, time

router = APIRouter()

TARGETS = "/etc/smokeping/config.d/Targets"
BEGIN = "# BEGIN_TM_MANAGED"
END   = "# END_TM_MANAGED"
GROUP_HDR = (
    BEGIN + "\n"
    "+ TestMachine\n"
    "menu = TestMachine\n"
    "title = Hosts gestiti da TestMachine\n\n"
    + END + "\n"
)

RRD_BASE = "/var/lib/smokeping"
RRD_DIR  = os.path.join(RRD_BASE, "TestMachine")

def head(title: str) -> str:
    # In f-string le graffe di CSS/JS devono essere raddoppiate {{ }}
    return f"""<!doctype html>
<html><head>
<meta charset='utf-8'/><meta name='viewport' content='width=device-width,initial-scale=1'/>
<title>{title}</title>
<link rel='stylesheet' href='/static/styles.css'/>
<style>
.hosts {{ width:100%; border-collapse:separate; border-spacing:0 8px; }}
.hosts th {{ font-weight:600; color:#cfe7ff; text-align:left; padding:6px 10px; }}
.hosts td {{ padding:10px 12px; background:rgba(255,255,255,.04); border-radius:12px; }}
.row-flex {{ display:flex; gap:12px; align-items:center; justify-content:space-between; }}
.pill {{ font-size:.90rem; opacity:.85; }}
.badge {{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:rgba(255,255,255,.06); padding:.2rem .45rem; border-radius:.45rem; }}
.btn.small {{ padding:.35rem .65rem; font-size:.9rem; }}
.btn.ghost {{ background:transparent; border:1px solid rgba(255,255,255,.18); }}
.muted2 {{ opacity:.8; }}
</style>
</head><body>
<div class='container'>
  <div class='nav'>
    <div class='brand'><img src='/static/img/logo.svg' alt='Logo' class='logo'><span>TestMachine</span></div>
    <div class='links'><a href='/'>Home</a></div>
  </div>
"""

def read_targets() -> str:
    with open(TARGETS, "r", encoding="utf-8") as f:
        return f.read()

def write_targets(txt: str) -> None:
    with open(TARGETS, "w", encoding="utf-8") as f:
        f.write(txt)

def ensure_group(txt: str) -> str:
    if BEGIN not in txt or END not in txt:
        if not txt.endswith("\n"):
            txt += "\n"
        txt += "\n" + GROUP_HDR
    return txt

def slice_managed(txt: str):
    m = re.search(rf"(?ms)^{re.escape(BEGIN)}\s*(.*?)^\s*{re.escape(END)}\s*$", txt)
    if not m:
        txt = ensure_group(txt)
        m = re.search(rf"(?ms)^{re.escape(BEGIN)}\s*(.*?)^\s*{re.escape(END)}\s*$", txt)
    pre = txt[:m.start()]
    managed = m.group(1)
    post = txt[m.end():]
    return pre, managed, post

def parse_hosts(managed: str):
    out = []
    for m in re.finditer(r"(?ms)^\+\+\s*([A-Za-z0-9_.-]+)\s*\n(.*?)(?=^\+\+|\Z)", managed):
        name = m.group(1)
        body = m.group(2)
        maddr = re.search(r"(?m)^\s*host\s*=\s*([^\s#]+)", body)
        if maddr:
            out.append((name, maddr.group(1)))
    return out

def render_targets_page(hosts):
    rows = []
    if hosts:
        for name, addr in hosts:
            rows.append(
                "<tr><td>"
                "<div class='row-flex'><div>"
                f"<div class='pill'><strong>{name}</strong></div>"
                f"<div class='muted2'><span class='badge'>{addr}</span></div>"
                "</div>"
                f"<div style='display:flex;gap:.5rem'>"
                f"<button class='btn ghost small' onclick=\\\"delHost('{name}')\\\">Elimina</button>"
                "</div></div>"
                "</td></tr>"
            )
    else:
        rows.append("<tr><td class='muted'>Nessun host gestito.</td></tr>")
    table = (
        "<table class='hosts' aria-label='Host gestiti'>"
        "<thead><tr><th>Host gestiti</th></tr></thead>"
        "<tbody>" + "".join(rows) + "</tbody></table>"
    )

    return head("Targets") + f"""
    <div class='card' style='margin-top:14px'>
      <h2>Gestione Targets</h2>
      <div class='row' style='align-items:flex-start'>
        <div style='flex:1'>{table}</div>
        <div style='flex:1'>
          <h3>Aggiungi host</h3>
          <label>Nome</label>
          <input id='name' placeholder='es. host1' />
          <label>Indirizzo/IP</label>
          <input id='addr' placeholder='es. 8.8.8.8' />
          <div style='margin-top:10px'>
            <button class='btn' onclick='addHost()'>Aggiungi</button>
          </div>
          <p class='muted'>Gli host vengono inseriti sotto il gruppo <strong>TestMachine</strong>.</p>
          <div class='row' style='gap:10px;margin-top:10px'>
            <a class='btn secondary' href='/sp-admin/targets/raw'>Vedi file Targets (raw)</a>
            <a class='btn secondary' href='/sp-admin/export/rrd'>Esporta RRD (tar.gz)</a>
          </div>
        </div>
      </div>
    </div>
    </div>
    <script>
    async function addHost(){{
      const n = document.getElementById('name').value.trim();
      const a = document.getElementById('addr').value.trim();
      if(!n||!a){{ alert('Nome e indirizzo sono obbligatori'); return; }}
      const r = await fetch(`/sp-admin/hosts/add?name=${{encodeURIComponent(n)}}&address=${{encodeURIComponent(a)}}`);
      const j = await r.json();
      if(j.status==='ok') location.reload(); else alert(j.detail||'Errore');
    }}
    async function delHost(n){{
      if(!confirm(`Rimuovere ${{n}}?`)) return;
      const r = await fetch(`/sp-admin/hosts/delete?name=${{encodeURIComponent(n)}}`);
      const j = await r.json();
      if(j.status==='ok') location.reload(); else alert(j.detail||'Errore');
    }}
    </script>
    </body></html>
"""

@router.get("/", response_class=HTMLResponse)
def admin_home(request: Request):
    return head("SmokePing Admin") + """
    <div class='card'>
      <h2>SmokePing Admin</h2>
      <p class='muted'>Sezione amministrativa minima. Qui gestisci target e servizio.</p>
      <div class='row'>
        <a class='btn' href='/smokeping/'>Apri interfaccia SmokePing</a>
        <a class='btn secondary' href='/sp-admin/targets'>Vedi/gestisci Targets</a>
      </div>
      <div style='margin-top:10px'>
        <a class='btn danger' href='/sp-admin/restart'>Riavvia servizio</a>
      </div>
    </div></div></body></html>
"""

@router.get("/targets", response_class=HTMLResponse)
def targets_page(request: Request):
    txt = ensure_group(read_targets())
    pre, managed, post = slice_managed(txt)
    hosts = parse_hosts(managed)
    return HTMLResponse(render_targets_page(hosts))

@router.get("/targets/raw", response_class=PlainTextResponse)
def targets_raw():
    return PlainTextResponse(read_targets(), media_type="text/plain; charset=utf-8")

def check_and_hup():
    rc, out, err = run(["/usr/sbin/smokeping","--check"])
    if rc != 0:
        return False, out, err
    run(["sudo","-n","/bin/systemctl","reload","smokeping"])
    return True, out, ""

@router.get("/hosts/add")
def add_host(name: str = Query(None), address: str = Query(None)):
    if not name or not address:
        return JSONResponse({"status":"error","detail":"name e address sono obbligatori"})
    if not re.fullmatch(r"[A-Za-z0-9_.-]{1,64}", name):
        return JSONResponse({"status":"error","detail":"Nome non valido"}, status_code=400)

    txt = ensure_group(read_targets())
    pre, managed, post = slice_managed(txt)
    hosts = parse_hosts(managed)
    if any(n.lower()==name.lower() for n,_ in hosts):
        return JSONResponse({"status":"error","detail":"Host gi√† presente"}, status_code=409)

    stanza = (
        f"++ {name}\n"
        f"menu = {name}\n"
        f"title = {name}\n"
        f"host = {address}\n\n"
    )
    new_managed = managed + stanza
    new_txt = pre + BEGIN + "\n" + new_managed + END + post
    write_targets(new_txt)

    ok, out, err = check_and_hup()
    if not ok:
        write_targets(txt)  # rollback
        return JSONResponse({"status":"error","detail":"Config non valida","check_out":out,"check_err":err}, status_code=500)
    return JSONResponse({"status":"ok"})

@router.get("/hosts/delete")
def delete_host(name: str = Query(None)):
    if not name:
        return JSONResponse({"status":"error","detail":"name obbligatorio"}, status_code=400)
    txt = ensure_group(read_targets())
    pre, managed, post = slice_managed(txt)
    patt = rf"(?ms)^\+\+\s*{re.escape(name)}\s*\n.*?(?=^\+\+|\Z)"
    new_managed, n = re.subn(patt, "", managed)
    if n == 0:
        return JSONResponse({"status":"error","detail":"Host non trovato"}, status_code=404)
    new_txt = pre + BEGIN + "\n" + new_managed + END + post
    write_targets(new_txt)

    ok, out, err = check_and_hup()
    if not ok:
        write_targets(txt)  # rollback
        return JSONResponse({"status":"error","detail":"Config non valida","check_out":out,"check_err":err}, status_code=500)
    return JSONResponse({"status":"ok"})

@router.get("/restart")
def sp_restart():
    rc, out, err = run(["sudo","-n","/bin/systemctl","restart","smokeping"])
    if rc != 0:
        return JSONResponse({"status":"error","out":out,"err":err})
    return JSONResponse({"status":"ok"})

@router.get("/export/rrd")
def export_rrd():
    files=[]
    if os.path.isdir(RRD_DIR):
        for fn in os.listdir(RRD_DIR):
            if fn.endswith(".rrd"):
                files.append(os.path.join(RRD_DIR, fn))
    if not files:
        return JSONResponse({"status":"error","detail":"Nessun file RRD da esportare"}, status_code=404)

    os.makedirs("/opt/netprobe/tmp", exist_ok=True)
    ts = time.strftime("%Y%m%d-%H%M%S")
    outpath = f"/opt/netprobe/tmp/smokeping-TestMachine-{ts}.tar.gz"
    with tarfile.open(outpath, "w:gz") as tar:
        for f in files:
            tar.add(f, arcname=os.path.join("TestMachine", os.path.basename(f)))
    return FileResponse(outpath, media_type="application/gzip", filename=os.path.basename(outpath))
